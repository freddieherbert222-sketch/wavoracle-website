{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { throttleTime } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./speed.service\";\nexport let EtaPipe = /*#__PURE__*/(() => {\n  class EtaPipe {\n    transform(value, ...args) {\n      if (value === null) {\n        return null;\n      }\n      if (value < 60) {\n        return `${Math.round(value)}s`;\n      }\n      if (value < 3600) {\n        return `${Math.floor(value / 60)}m ${Math.round(value % 60)}s`;\n      }\n      const hours = Math.floor(value / 3600);\n      const minutes = value % 3600;\n      return `${hours}h ${Math.floor(minutes / 60)}m ${Math.round(minutes % 60)}s`;\n    }\n    static {\n      this.ɵfac = function EtaPipe_Factory(t) {\n        return new (t || EtaPipe)();\n      };\n    }\n    static {\n      this.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n        name: \"eta\",\n        type: EtaPipe,\n        pure: true\n      });\n    }\n  }\n  return EtaPipe;\n})();\nexport let SpeedPipe = /*#__PURE__*/(() => {\n  class SpeedPipe {\n    constructor(speedService) {\n      this.speedService = speedService;\n      this.speedSubject = new BehaviorSubject(0);\n      this.formattedSpeed = '';\n      // Throttle updates to once per second\n      this.speedSubject.pipe(throttleTime(1000)).subscribe(speed => {\n        // If speed is invalid or 0, return empty string\n        if (speed === null || speed === undefined || isNaN(speed) || speed <= 0) {\n          this.formattedSpeed = '';\n          return;\n        }\n        const k = 1024;\n        const dm = 2;\n        const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s', 'TB/s', 'PB/s', 'EB/s', 'ZB/s', 'YB/s'];\n        const i = Math.floor(Math.log(speed) / Math.log(k));\n        this.formattedSpeed = parseFloat((speed / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n      });\n    }\n    transform(value, ...args) {\n      // If speed is invalid or 0, return empty string\n      if (value === null || value === undefined || isNaN(value) || value <= 0) {\n        return '';\n      }\n      // Update the speed subject\n      this.speedSubject.next(value);\n      // Return the last formatted speed\n      return this.formattedSpeed;\n    }\n    static {\n      this.ɵfac = function SpeedPipe_Factory(t) {\n        return new (t || SpeedPipe)(i0.ɵɵdirectiveInject(i1.SpeedService, 16));\n      };\n    }\n    static {\n      this.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n        name: \"speed\",\n        type: SpeedPipe,\n        pure: false\n      });\n    }\n  }\n  return SpeedPipe;\n})();\nexport let EncodeURIComponent = /*#__PURE__*/(() => {\n  class EncodeURIComponent {\n    transform(value, ...args) {\n      return encodeURIComponent(value);\n    }\n    static {\n      this.ɵfac = function EncodeURIComponent_Factory(t) {\n        return new (t || EncodeURIComponent)();\n      };\n    }\n    static {\n      this.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n        name: \"encodeURIComponent\",\n        type: EncodeURIComponent,\n        pure: true\n      });\n    }\n  }\n  return EncodeURIComponent;\n})();\nexport let FileSizePipe = /*#__PURE__*/(() => {\n  class FileSizePipe {\n    transform(value) {\n      if (isNaN(value) || value === 0) return '0 Bytes';\n      const units = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n      const unitIndex = Math.floor(Math.log(value) / Math.log(1000)); // Use 1000 for common units\n      const unitValue = value / Math.pow(1000, unitIndex);\n      return `${unitValue.toFixed(2)} ${units[unitIndex]}`;\n    }\n    static {\n      this.ɵfac = function FileSizePipe_Factory(t) {\n        return new (t || FileSizePipe)();\n      };\n    }\n    static {\n      this.ɵpipe = /*@__PURE__*/i0.ɵɵdefinePipe({\n        name: \"fileSize\",\n        type: FileSizePipe,\n        pure: true\n      });\n    }\n  }\n  return FileSizePipe;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}