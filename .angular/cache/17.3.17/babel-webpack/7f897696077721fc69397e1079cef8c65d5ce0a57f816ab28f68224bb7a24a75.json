{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/asus/wavoracle website/metube/ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let AudioFileHandlerService = /*#__PURE__*/(() => {\n  class AudioFileHandlerService {\n    constructor(http) {\n      this.http = http;\n      this.audioFilesSubject = new BehaviorSubject([]);\n      this.selectedAudioFileSubject = new BehaviorSubject(null);\n      this.metadataCache = new Map();\n      this.audioFiles$ = this.audioFilesSubject.asObservable();\n      this.selectedAudioFile$ = this.selectedAudioFileSubject.asObservable();\n    }\n    /**\n     * Process completed WavOracle download and prepare for audio analysis\n     */\n    processCompletedDownload(download) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log(`🎵 Processing completed download: ${download.title}`);\n          // Check if it's an audio file\n          if (!_this.isAudioFormat(download.format)) {\n            console.log(`⏭️ Skipping non-audio format: ${download.format}`);\n            return null;\n          }\n          // Get or fetch YouTube metadata\n          const metadata = yield _this.getYouTubeMetadata(download.url, download.title);\n          // Create File object from the downloaded file\n          const audioFile = yield _this.createFileFromDownload(download);\n          if (!audioFile) {\n            console.error('❌ Failed to create File object from download');\n            return null;\n          }\n          // Create AudioFileInfo object\n          const audioFileInfo = {\n            id: download.id,\n            file: audioFile,\n            title: metadata.title,\n            artist: metadata.artist || 'Unknown Artist',\n            duration: metadata.duration,\n            format: download.format,\n            quality: download.quality,\n            url: download.url,\n            downloadDate: new Date(),\n            analysisStatus: 'pending'\n          };\n          // Add to audio files list\n          _this.addAudioFile(audioFileInfo);\n          console.log(`✅ Audio file processed successfully: ${audioFileInfo.title}`);\n          return audioFileInfo;\n        } catch (error) {\n          console.error('❌ Error processing completed download:', error);\n          return null;\n        }\n      })();\n    }\n    /**\n     * Check if the format is audio\n     */\n    isAudioFormat(format) {\n      const audioFormats = ['mp3', 'wav', 'flac', 'aac', 'ogg', 'm4a'];\n      return audioFormats.includes(format.toLowerCase());\n    }\n    /**\n     * Get YouTube metadata (with caching)\n     */\n    getYouTubeMetadata(url, fallbackTitle) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        // Check cache first\n        if (_this2.metadataCache.has(url)) {\n          return _this2.metadataCache.get(url);\n        }\n        try {\n          // Try to extract metadata from the URL or use fallback\n          const metadata = {\n            title: fallbackTitle,\n            artist: _this2.extractArtistFromTitle(fallbackTitle),\n            duration: 0,\n            // Will be updated when file is processed\n            thumbnail: '',\n            description: '',\n            tags: []\n          };\n          // Cache the metadata\n          _this2.metadataCache.set(url, metadata);\n          return metadata;\n        } catch (error) {\n          console.warn('⚠️ Failed to get YouTube metadata, using fallback:', error);\n          return {\n            title: fallbackTitle,\n            artist: _this2.extractArtistFromTitle(fallbackTitle),\n            duration: 0,\n            thumbnail: '',\n            description: '',\n            tags: []\n          };\n        }\n      })();\n    }\n    /**\n     * Extract artist from title (common patterns)\n     */\n    extractArtistFromTitle(title) {\n      // Common patterns: \"Artist - Song Title\", \"Artist: Song Title\", \"Artist ft. Other - Song\"\n      const patterns = [/^(.+?)\\s*[-–—]\\s*(.+)$/,\n      // \"Artist - Song\"\n      /^(.+?)\\s*:\\s*(.+)$/,\n      // \"Artist: Song\"\n      /^(.+?)\\s+ft\\.?\\s+(.+?)\\s*[-–—]\\s*(.+)$/,\n      // \"Artist ft. Other - Song\"\n      /^(.+?)\\s+feat\\.?\\s+(.+?)\\s*[-–—]\\s*(.+)$/ // \"Artist feat. Other - Song\"\n      ];\n      for (const pattern of patterns) {\n        const match = title.match(pattern);\n        if (match) {\n          return match[1].trim();\n        }\n      }\n      return 'Unknown Artist';\n    }\n    /**\n     * Create File object from WavOracle download\n     */\n    createFileFromDownload(download) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          // For now, we'll create a placeholder File object\n          // In a real implementation, you'd need to access the actual file from the filesystem\n          // This is a limitation of web browsers - they can't directly access downloaded files\n          // Create a mock file for demonstration purposes\n          const mockFile = new File([''], download.filename || 'audio.mp3', {\n            type: _this3.getMimeType(download.format),\n            lastModified: Date.now()\n          });\n          console.log(`📁 Created mock file: ${mockFile.name}`);\n          return mockFile;\n        } catch (error) {\n          console.error('❌ Error creating file from download:', error);\n          return null;\n        }\n      })();\n    }\n    /**\n     * Get MIME type for audio format\n     */\n    getMimeType(format) {\n      const mimeTypes = {\n        'mp3': 'audio/mpeg',\n        'wav': 'audio/wav',\n        'flac': 'audio/flac',\n        'aac': 'audio/aac',\n        'ogg': 'audio/ogg',\n        'm4a': 'audio/mp4'\n      };\n      return mimeTypes[format.toLowerCase()] || 'audio/mpeg';\n    }\n    /**\n     * Add audio file to the list\n     */\n    addAudioFile(audioFileInfo) {\n      const currentFiles = this.audioFilesSubject.value;\n      const updatedFiles = [...currentFiles, audioFileInfo];\n      this.audioFilesSubject.next(updatedFiles);\n    }\n    /**\n     * Select an audio file for analysis\n     */\n    selectAudioFile(audioFileInfo) {\n      this.selectedAudioFileSubject.next(audioFileInfo);\n      console.log(`🎯 Selected audio file for analysis: ${audioFileInfo.title}`);\n    }\n    /**\n     * Update analysis status\n     */\n    updateAnalysisStatus(fileId, status, result) {\n      const currentFiles = this.audioFilesSubject.value;\n      const fileIndex = currentFiles.findIndex(f => f.id === fileId);\n      if (fileIndex !== -1) {\n        currentFiles[fileIndex].analysisStatus = status;\n        if (result) {\n          currentFiles[fileIndex].analysisResult = result;\n        }\n        this.audioFilesSubject.next([...currentFiles]);\n        console.log(`📊 Updated analysis status for ${currentFiles[fileIndex].title}: ${status}`);\n      }\n    }\n    /**\n     * Get the currently selected audio file\n     */\n    getSelectedAudioFile() {\n      return this.selectedAudioFileSubject.value;\n    }\n    /**\n     * Get all audio files\n     */\n    getAllAudioFiles() {\n      return this.audioFilesSubject.value;\n    }\n    /**\n     * Remove audio file from list\n     */\n    removeAudioFile(fileId) {\n      const currentFiles = this.audioFilesSubject.value;\n      const updatedFiles = currentFiles.filter(f => f.id !== fileId);\n      this.audioFilesSubject.next(updatedFiles);\n      // If the removed file was selected, clear selection\n      if (this.selectedAudioFileSubject.value?.id === fileId) {\n        this.selectedAudioFileSubject.next(null);\n      }\n    }\n    /**\n     * Clear all audio files\n     */\n    clearAllAudioFiles() {\n      this.audioFilesSubject.next([]);\n      this.selectedAudioFileSubject.next(null);\n      console.log('🗑️ Cleared all audio files');\n    }\n    /**\n     * Get audio files by analysis status\n     */\n    getAudioFilesByStatus(status) {\n      return this.audioFilesSubject.value.filter(f => f.analysisStatus === status);\n    }\n    /**\n     * Get pending analysis files\n     */\n    getPendingAnalysisFiles() {\n      return this.getAudioFilesByStatus('pending');\n    }\n    /**\n     * Get completed analysis files\n     */\n    getCompletedAnalysisFiles() {\n      return this.getAudioFilesByStatus('completed');\n    }\n    /**\n     * Generate standardized filename with key/BPM metadata\n     */\n    generateStandardizedFilename(audioFileInfo) {\n      const {\n        title,\n        artist,\n        format,\n        analysisResult\n      } = audioFileInfo;\n      // Extract song title and type from the full title\n      const {\n        songTitle,\n        songType\n      } = this.parseSongTitle(title);\n      // Check if we have analysis results with key/BPM\n      if (analysisResult && analysisResult.finalResult) {\n        const {\n          key,\n          bpm,\n          confidence\n        } = analysisResult.finalResult;\n        // Only use key/BPM if confidence is medium or high\n        if (confidence === 'high' || confidence === 'medium') {\n          return this.formatFilenameWithMetadata(artist, songTitle, key, bpm, format, songType);\n        }\n      }\n      // Fallback: No key/BPM available, use basic naming\n      return this.formatBasicFilename(artist, songTitle, format, songType);\n    }\n    /**\n     * Parse song title to extract actual title and type\n     */\n    parseSongTitle(fullTitle) {\n      const title = fullTitle.trim();\n      let songTitle = title;\n      let songType = 'Original';\n      // Check for common type indicators\n      const typePatterns = [{\n        pattern: /\\[instrumental\\]/i,\n        type: 'Instrumental'\n      }, {\n        pattern: /\\[acapella\\]/i,\n        type: 'Acapella'\n      }, {\n        pattern: /\\[karaoke\\]/i,\n        type: 'Karaoke'\n      }, {\n        pattern: /\\[remix\\]/i,\n        type: 'Remix'\n      }, {\n        pattern: /\\(instrumental\\)/i,\n        type: 'Instrumental'\n      }, {\n        pattern: /\\(acapella\\)/i,\n        type: 'Acapella'\n      }, {\n        pattern: /\\(karaoke\\)/i,\n        type: 'Karaoke'\n      }, {\n        pattern: /\\(remix\\)/i,\n        type: 'Remix'\n      }, {\n        pattern: /instrumental/i,\n        type: 'Instrumental'\n      }, {\n        pattern: /acapella/i,\n        type: 'Acapella'\n      }, {\n        pattern: /karaoke/i,\n        type: 'Karaoke'\n      }, {\n        pattern: /remix/i,\n        type: 'Remix'\n      }];\n      for (const {\n        pattern,\n        type\n      } of typePatterns) {\n        if (pattern.test(title)) {\n          songType = type;\n          songTitle = title.replace(pattern, '').trim();\n          break;\n        }\n      }\n      return {\n        songTitle,\n        songType\n      };\n    }\n    /**\n     * Format filename with key/BPM metadata\n     */\n    formatFilenameWithMetadata(artist, songTitle, key, bpm, format, songType) {\n      const cleanArtist = this.cleanFilename(artist);\n      const cleanTitle = this.cleanFilename(songTitle);\n      const cleanKey = this.cleanFilename(key);\n      const cleanBPM = Math.round(bpm).toString();\n      let filename = `${cleanArtist} - ${cleanTitle}`;\n      // Add key and BPM\n      if (cleanKey && cleanBPM) {\n        filename += ` [${cleanKey}] [${cleanBPM}]`;\n      } else if (cleanKey) {\n        filename += ` [${cleanKey}]`;\n      } else if (cleanBPM) {\n        filename += ` [${cleanBPM}]`;\n      }\n      // Add song type if not original\n      if (songType !== 'Original') {\n        filename += ` [${songType}]`;\n      }\n      return `${filename}.${format.toLowerCase()}`;\n    }\n    /**\n     * Format basic filename without key/BPM\n     */\n    formatBasicFilename(artist, songTitle, format, songType) {\n      const cleanArtist = this.cleanFilename(artist);\n      const cleanTitle = this.cleanFilename(songTitle);\n      let filename = `${cleanArtist} - ${cleanTitle}`;\n      // Add song type if not original\n      if (songType !== 'Original') {\n        filename += ` [${songType}]`;\n      }\n      return `${filename}.${format.toLowerCase()}`;\n    }\n    /**\n     * Clean filename to remove invalid characters\n     */\n    cleanFilename(filename) {\n      return filename.replace(/[<>:\"/\\\\|?*]/g, '') // Remove invalid Windows characters\n      .replace(/\\s+/g, ' ') // Normalize spaces\n      .trim();\n    }\n    /**\n     * Get download filename for user (this is what they'll see)\n     */\n    getDownloadFilename(audioFileInfo) {\n      return this.generateStandardizedFilename(audioFileInfo);\n    }\n    static {\n      this.ɵfac = function AudioFileHandlerService_Factory(t) {\n        return new (t || AudioFileHandlerService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: AudioFileHandlerService,\n        factory: AudioFileHandlerService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return AudioFileHandlerService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}