{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, ApplicationRef, NgModule, makeEnvironmentProviders } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { share } from 'rxjs/operators';\nimport * as ioModule from 'socket.io-client';\nclass WrappedSocket {\n  config;\n  appRef;\n  subscribersCounter = {};\n  eventObservables$ = {};\n  namespaces = {};\n  ioSocket;\n  emptyConfig = {\n    url: '',\n    options: {}\n  };\n  constructor(config, appRef) {\n    this.config = config;\n    this.appRef = appRef;\n    if (config === undefined) {\n      config = this.emptyConfig;\n    }\n    const url = config.url;\n    const options = config.options;\n    const ioFunc = ioModule.default ? ioModule.default : ioModule;\n    this.ioSocket = ioFunc(url, options);\n  }\n  get auth() {\n    return this.ioSocket.auth;\n  }\n  set auth(value) {\n    this.ioSocket.auth = value;\n  }\n  /** readonly access to io manager */\n  get io() {\n    return this.ioSocket.io;\n  }\n  /** alias to connect */\n  get open() {\n    return this.connect;\n  }\n  /** alias to disconnect */\n  get close() {\n    return this.disconnect;\n  }\n  /**\n   * Gets a WrappedSocket for the given namespace.\n   *\n   * @note if an existing socket exists for the given namespace, it will be reused.\n   *\n   * @param namespace the namespace to create a new socket based on the current config.\n   *        If empty or `/`, then the current instance is returned.\n   * @returns a socket that is bound to the given namespace. If namespace is empty or `/`,\n   *          then `this` is returned, otherwise another instance is returned, creating\n   *          it if it's the first use of such namespace.\n   */\n  of(namespace) {\n    if (!namespace || namespace === '/') {\n      return this;\n    }\n    const existing = this.namespaces[namespace];\n    if (existing) {\n      return existing;\n    }\n    const {\n      url,\n      ...rest\n    } = this.config;\n    const config = {\n      url: !url.endsWith('/') && !namespace.startsWith('/') ? `${url}/${namespace}` : `${url}${namespace}`,\n      ...rest\n    };\n    const created = new WrappedSocket(config, this.appRef);\n    this.namespaces[namespace] = created;\n    return created;\n  }\n  on(eventName, callback) {\n    this.ioSocket.on(eventName, callback);\n    return this;\n  }\n  once(eventName, callback) {\n    this.ioSocket.once(eventName, callback);\n    return this;\n  }\n  connect() {\n    this.ioSocket.connect();\n    return this;\n  }\n  disconnect() {\n    this.ioSocket.disconnect();\n    return this;\n  }\n  emit(eventName, ...args) {\n    this.ioSocket.emit(eventName, ...args);\n    return this;\n  }\n  send(..._args) {\n    this.ioSocket.send.apply(this.ioSocket, arguments);\n    return this;\n  }\n  emitWithAck(eventName, ...args) {\n    return this.ioSocket.emitWithAck(eventName, ...args);\n  }\n  removeListener(eventName, callback) {\n    this.ioSocket.removeListener(eventName, callback);\n    return this;\n  }\n  removeAllListeners(eventName) {\n    this.ioSocket.removeAllListeners(eventName);\n    return this;\n  }\n  fromEvent(eventName) {\n    if (!this.subscribersCounter[eventName]) {\n      this.subscribersCounter[eventName] = 0;\n    }\n    this.subscribersCounter[eventName]++;\n    if (!this.eventObservables$[eventName]) {\n      this.eventObservables$[eventName] = new Observable(observer => {\n        const listener = data => {\n          observer.next(data);\n          this.appRef.tick();\n        };\n        this.ioSocket.on(eventName, listener);\n        return () => {\n          this.subscribersCounter[eventName]--;\n          if (this.subscribersCounter[eventName] === 0) {\n            this.ioSocket.removeListener(eventName, listener);\n            delete this.eventObservables$[eventName];\n          }\n        };\n      }).pipe(share());\n    }\n    return this.eventObservables$[eventName];\n  }\n  fromOneTimeEvent(eventName) {\n    return new Promise(resolve => this.once(eventName, resolve));\n  }\n  listeners(eventName) {\n    return this.ioSocket.listeners(eventName);\n  }\n  hasListeners(eventName) {\n    return this.ioSocket.hasListeners(eventName);\n  }\n  listenersAny() {\n    return this.ioSocket.listenersAny();\n  }\n  listenersAnyOutgoing() {\n    return this.ioSocket.listenersAnyOutgoing();\n  }\n  off(eventName, listener) {\n    this.ioSocket.off(eventName, listener);\n    return this;\n  }\n  offAny(callback) {\n    this.ioSocket.offAny(callback);\n    return this;\n  }\n  offAnyOutgoing(callback) {\n    this.ioSocket.offAnyOutgoing(callback);\n    return this;\n  }\n  onAny(callback) {\n    this.ioSocket.onAny(callback);\n    return this;\n  }\n  onAnyOutgoing(callback) {\n    this.ioSocket.onAnyOutgoing(callback);\n    return this;\n  }\n  prependAny(callback) {\n    this.ioSocket.prependAny(callback);\n    return this;\n  }\n  prependAnyOutgoing(callback) {\n    this.ioSocket.prependAnyOutgoing(callback);\n    return this;\n  }\n  timeout(value) {\n    this.ioSocket.timeout(value);\n    return this;\n  }\n  get volatile() {\n    // this getter has a side-effect of turning the socket instance true,\n    // but it returns the actual instance, so we need to get the value to force the side effect\n    const _ = this.ioSocket.volatile;\n    return this;\n  }\n  get active() {\n    return this.ioSocket.active;\n  }\n  get connected() {\n    return this.ioSocket.connected;\n  }\n  get disconnected() {\n    return this.ioSocket.disconnected;\n  }\n  get recovered() {\n    return this.ioSocket.recovered;\n  }\n  get id() {\n    return this.ioSocket.id;\n  }\n  compress(value) {\n    this.ioSocket.compress(value);\n    return this;\n  }\n}\n\n/** Socket factory */\nfunction SocketFactory(config, appRef) {\n  return new WrappedSocket(config, appRef);\n}\nconst SOCKET_CONFIG_TOKEN = new InjectionToken('__SOCKET_IO_CONFIG__');\nlet SocketIoModule = /*#__PURE__*/(() => {\n  class SocketIoModule {\n    static forRoot(config) {\n      return {\n        ngModule: SocketIoModule,\n        providers: [{\n          provide: SOCKET_CONFIG_TOKEN,\n          useValue: config\n        }, {\n          provide: WrappedSocket,\n          useFactory: SocketFactory,\n          deps: [SOCKET_CONFIG_TOKEN, ApplicationRef]\n        }]\n      };\n    }\n    static ɵfac = function SocketIoModule_Factory(t) {\n      return new (t || SocketIoModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: SocketIoModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return SocketIoModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst provideSocketIo = config => {\n  return makeEnvironmentProviders([{\n    provide: SOCKET_CONFIG_TOKEN,\n    useValue: config\n  }, {\n    provide: WrappedSocket,\n    useFactory: SocketFactory,\n    deps: [SOCKET_CONFIG_TOKEN, ApplicationRef]\n  }]);\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SOCKET_CONFIG_TOKEN, WrappedSocket as Socket, SocketIoModule, provideSocketIo };\n//# sourceMappingURL=ngx-socket-io.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}