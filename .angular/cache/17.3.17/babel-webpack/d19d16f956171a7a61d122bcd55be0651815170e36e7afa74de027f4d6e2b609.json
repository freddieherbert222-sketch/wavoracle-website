{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/asus/wavoracle website/metube/ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let WebScrapingService = /*#__PURE__*/(() => {\n  class WebScrapingService {\n    constructor(http) {\n      this.http = http;\n      this.TUNEBAT_BASE_URL = 'https://tunebat.com';\n      this.REDDIT_BASE_URL = 'https://www.reddit.com';\n      this.MUSICBRAINZ_BASE_URL = 'https://musicbrainz.org';\n    }\n    /**\n     * Scrape multiple sources for music data\n     */\n    scrapeAllSources(songTitle, artist) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        const results = [];\n        try {\n          // Try Tunebat first (most reliable for key/BPM)\n          const tunebatResult = yield _this.scrapeTunebat(songTitle, artist);\n          if (tunebatResult.success && tunebatResult.data) {\n            results.push(tunebatResult.data);\n          }\n          // Try Reddit for community insights\n          const redditResult = yield _this.scrapeReddit(songTitle, artist);\n          if (redditResult.success && redditResult.data) {\n            results.push(redditResult.data);\n          }\n          // Try MusicBrainz for metadata\n          const musicbrainzResult = yield _this.scrapeMusicBrainz(songTitle, artist);\n          if (musicbrainzResult.success && musicbrainzResult.data) {\n            results.push(musicbrainzResult.data);\n          }\n        } catch (error) {\n          console.error('❌ Error scraping music data:', error);\n        }\n        return results;\n      })();\n    }\n    /**\n     * Scrape Tunebat for key/BPM data\n     */\n    scrapeTunebat(songTitle, artist) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const searchQuery = artist ? `${artist} ${songTitle}` : songTitle;\n          const searchUrl = `${_this2.TUNEBAT_BASE_URL}/Search?q=${encodeURIComponent(searchQuery)}`;\n          console.log(`🔍 Scraping Tunebat: ${searchUrl}`);\n          // Note: In a real implementation, you'd need a backend proxy due to CORS\n          // For now, we'll simulate the response\n          const mockData = {\n            key: _this2.generateMockKey(),\n            bpm: _this2.generateMockBPM(),\n            confidence: 'medium',\n            source: 'Tunebat',\n            url: searchUrl,\n            timestamp: new Date()\n          };\n          return {\n            success: true,\n            data: mockData,\n            source: 'Tunebat'\n          };\n        } catch (error) {\n          console.error('❌ Tunebat scraping failed:', error);\n          return {\n            success: false,\n            error: 'Tunebat scraping failed',\n            source: 'Tunebat'\n          };\n        }\n      })();\n    }\n    /**\n     * Scrape Reddit for community insights\n     */\n    scrapeReddit(songTitle, artist) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const searchQuery = artist ? `${artist} ${songTitle}` : songTitle;\n          const searchUrl = `${_this3.REDDIT_BASE_URL}/search.json?q=${encodeURIComponent(searchQuery)}&restrict_sr=on&t=all&sort=relevance`;\n          console.log(`🔍 Scraping Reddit: ${searchUrl}`);\n          // Note: Reddit API requires proper authentication\n          // For now, we'll simulate community insights\n          const mockData = {\n            key: _this3.generateMockKey(),\n            bpm: _this3.generateMockBPM(),\n            confidence: 'low',\n            source: 'Reddit Community',\n            url: searchUrl,\n            timestamp: new Date()\n          };\n          return {\n            success: true,\n            data: mockData,\n            source: 'Reddit'\n          };\n        } catch (error) {\n          console.error('❌ Reddit scraping failed:', error);\n          return {\n            success: false,\n            error: 'Reddit scraping failed',\n            source: 'Reddit'\n          };\n        }\n      })();\n    }\n    /**\n     * Scrape MusicBrainz for metadata\n     */\n    scrapeMusicBrainz(songTitle, artist) {\n      var _this4 = this;\n      return _asyncToGenerator(function* () {\n        try {\n          const searchQuery = artist ? `${artist} ${songTitle}` : songTitle;\n          const searchUrl = `${_this4.MUSICBRAINZ_BASE_URL}/ws/2/recording/?query=${encodeURIComponent(searchQuery)}&fmt=json`;\n          console.log(`🔍 Scraping MusicBrainz: ${searchUrl}`);\n          // Note: MusicBrainz has rate limits and requires proper headers\n          // For now, we'll simulate metadata\n          const mockData = {\n            key: undefined,\n            // MusicBrainz doesn't provide key/BPM\n            bpm: undefined,\n            confidence: 'low',\n            source: 'MusicBrainz',\n            url: searchUrl,\n            timestamp: new Date()\n          };\n          return {\n            success: true,\n            data: mockData,\n            source: 'MusicBrainz'\n          };\n        } catch (error) {\n          console.error('❌ MusicBrainz scraping failed:', error);\n          return {\n            success: false,\n            error: 'MusicBrainz scraping failed',\n            source: 'MusicBrainz'\n          };\n        }\n      })();\n    }\n    /**\n     * Generate mock key for testing (remove in production)\n     */\n    generateMockKey() {\n      const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\n      const modes = ['major', 'minor'];\n      const key = keys[Math.floor(Math.random() * keys.length)];\n      const mode = modes[Math.floor(Math.random() * modes.length)];\n      return `${key} ${mode}`;\n    }\n    /**\n     * Generate mock BPM for testing (remove in production)\n     */\n    generateMockBPM() {\n      // Common BPM ranges for different genres\n      const bpmRanges = [[60, 80],\n      // Slow\n      [80, 120],\n      // Medium\n      [120, 140],\n      // Fast\n      [140, 180] // Very Fast\n      ];\n      const range = bpmRanges[Math.floor(Math.random() * bpmRanges.length)];\n      return Math.floor(Math.random() * (range[1] - range[0])) + range[0];\n    }\n    /**\n     * Get the best available data from all sources\n     */\n    getBestData(results) {\n      if (results.length === 0) return null;\n      // Sort by confidence (high > medium > low)\n      const confidenceOrder = {\n        high: 3,\n        medium: 2,\n        low: 1\n      };\n      return results.sort((a, b) => confidenceOrder[b.confidence] - confidenceOrder[a.confidence])[0];\n    }\n    /**\n     * Check if any source has key/BPM data\n     */\n    hasKeyOrBPMData(results) {\n      return results.some(result => result.key || result.bpm);\n    }\n    static {\n      this.ɵfac = function WebScrapingService_Factory(t) {\n        return new (t || WebScrapingService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WebScrapingService,\n        factory: WebScrapingService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WebScrapingService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}