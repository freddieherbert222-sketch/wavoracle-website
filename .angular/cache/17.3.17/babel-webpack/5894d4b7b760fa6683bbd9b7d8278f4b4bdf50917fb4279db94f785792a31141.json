{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/asus/wavoracle website/metube/ui/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { HttpHeaders } from '@angular/common/http';\nimport { environment } from '../environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./web-scraping.service\";\nexport let DeepSeekAIService = /*#__PURE__*/(() => {\n  class DeepSeekAIService {\n    constructor(http, webScrapingService) {\n      this.http = http;\n      this.webScrapingService = webScrapingService;\n      this.apiUrl = 'https://api.deepseek.com/v1/chat/completions';\n      this.apiKey = environment.deepseekApiKey;\n      // Cost Control & Monitoring\n      this.dailyTokenUsage = 0;\n      this.userTokenUsage = new Map();\n      this.requestCache = new Map();\n      this.lastResetDate = new Date().toDateString();\n      // Default cost control settings (FREE TIER FRIENDLY)\n      this.costConfig = {\n        maxTokensPerDay: 10000,\n        // Conservative daily limit\n        maxTokensPerUser: 2000,\n        // Per user daily limit\n        maxTokensPerRequest: 800,\n        // Reduced from 1000\n        enableCaching: true,\n        // Cache results to save tokens\n        enableFallbacks: true,\n        // Use free alternatives when possible\n        enableRateLimiting: true // Prevent abuse\n      };\n      this.resetDailyUsage();\n    }\n    /**\n     * Generate AI insights with cost control\n     */\n    generateMusicalInsights(youtubeTitle, audioAnalysisResult, userId) {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        try {\n          console.log(`üîÆ Generating AI insights for: ${youtubeTitle}`);\n          // Check cost control limits\n          if (!_this.canMakeRequest(userId)) {\n            return _this.generateFallbackInsights(youtubeTitle, audioAnalysisResult);\n          }\n          // Check cache first (save tokens!)\n          const cacheKey = _this.generateCacheKey(youtubeTitle, audioAnalysisResult);\n          if (_this.costConfig.enableCaching && _this.requestCache.has(cacheKey)) {\n            console.log('üíæ Returning cached AI insights (saving tokens!)');\n            return _this.requestCache.get(cacheKey);\n          }\n          // Create optimized prompts (reduce token usage)\n          const systemPrompt = _this.createOptimizedSystemPrompt();\n          const userPrompt = _this.createOptimizedUserPrompt(youtubeTitle, audioAnalysisResult);\n          // Make API request with reduced token limit\n          const response = yield _this.makeDeepSeekRequest(systemPrompt, userPrompt);\n          // Track token usage\n          _this.trackTokenUsage(response.usage.total_tokens, userId);\n          // Parse the response into structured insights\n          const insights = _this.parseAIResponse(response.choices[0].message.content, youtubeTitle);\n          // Cache the result (save future tokens!)\n          if (_this.costConfig.enableCaching) {\n            _this.requestCache.set(cacheKey, insights);\n          }\n          console.log(`‚úÖ AI insights generated successfully (${response.usage.total_tokens} tokens used)`);\n          return insights;\n        } catch (error) {\n          console.error('‚ùå Failed to generate AI insights:', error);\n          // Always fallback to free alternatives\n          return _this.generateFallbackInsights(youtubeTitle, audioAnalysisResult);\n        }\n      })();\n    }\n    /**\n     * Check if we can make a new request (cost control)\n     */\n    canMakeRequest(userId) {\n      // Reset daily usage if it's a new day\n      this.resetDailyUsage();\n      // Check daily limit\n      if (this.dailyTokenUsage >= this.costConfig.maxTokensPerDay) {\n        console.warn('‚ö†Ô∏è Daily token limit reached, using fallback');\n        return false;\n      }\n      // Check user limit\n      if (userId && this.userTokenUsage.get(userId) >= this.costConfig.maxTokensPerUser) {\n        console.warn(`‚ö†Ô∏è User ${userId} token limit reached, using fallback`);\n        return false;\n      }\n      return true;\n    }\n    /**\n     * Track token usage for cost control\n     */\n    trackTokenUsage(tokens, userId) {\n      this.dailyTokenUsage += tokens;\n      if (userId) {\n        const currentUsage = this.userTokenUsage.get(userId) || 0;\n        this.userTokenUsage.set(userId, currentUsage + tokens);\n      }\n      console.log(`üí∞ Token usage: Daily ${this.dailyTokenUsage}/${this.costConfig.maxTokensPerDay}, User ${userId}: ${this.userTokenUsage.get(userId) || 0}/${this.costConfig.maxTokensPerUser}`);\n    }\n    /**\n     * Reset daily usage counter\n     */\n    resetDailyUsage() {\n      const today = new Date().toDateString();\n      if (today !== this.lastResetDate) {\n        this.dailyTokenUsage = 0;\n        this.userTokenUsage.clear();\n        this.lastResetDate = today;\n        console.log('üîÑ Daily token usage reset');\n      }\n    }\n    /**\n     * Generate fallback insights using web scraping\n     */\n    generateFallbackInsights(youtubeTitle, audioAnalysisResult) {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        console.log('üÜì Generating FREE fallback insights using web scraping');\n        const {\n          artist,\n          songTitle\n        } = _this2.extractArtistAndTitle(youtubeTitle);\n        // Try web scraping for key/BPM data\n        let scrapedData = [];\n        try {\n          scrapedData = yield _this2.webScrapingService.scrapeAllSources(songTitle, artist);\n          console.log(`üîç Web scraping results: ${scrapedData.length} sources`);\n        } catch (error) {\n          console.warn('‚ö†Ô∏è Web scraping failed, using basic fallback');\n        }\n        // Use audio analysis results if available\n        let keyAnalysis = 'Analysis pending';\n        let bpmAnalysis = 'Analysis pending';\n        if (audioAnalysisResult && audioAnalysisResult.finalResult) {\n          const {\n            key,\n            bpm,\n            confidence\n          } = audioAnalysisResult.finalResult;\n          keyAnalysis = `Detected: ${key} (Confidence: ${confidence})`;\n          bpmAnalysis = `Detected: ${bpm} BPM (Confidence: ${confidence})`;\n        }\n        // Use web scraping data if available\n        if (scrapedData.length > 0) {\n          const bestData = _this2.webScrapingService.getBestData(scrapedData);\n          if (bestData) {\n            if (bestData.key && keyAnalysis === 'Analysis pending') {\n              keyAnalysis = `Web: ${bestData.key} (${bestData.source})`;\n            }\n            if (bestData.bpm && bpmAnalysis === 'Analysis pending') {\n              bpmAnalysis = `Web: ${bestData.bpm} BPM (${bestData.source})`;\n            }\n          }\n        }\n        return {\n          songTitle,\n          artist,\n          keyAnalysis,\n          bpmAnalysis,\n          keyChanges: ['Use your ears to detect key changes'],\n          bpmVariations: ['Use your ears to detect tempo changes'],\n          productionNotes: ['Listen carefully for production techniques'],\n          researchSources: scrapedData.length > 0 ? scrapedData.map(d => d.source) : ['Manual research recommended'],\n          confidence: 'medium',\n          timestamp: new Date()\n        };\n      })();\n    }\n    /**\n     * Create optimized system prompt (reduce tokens)\n     */\n    createOptimizedSystemPrompt() {\n      return `Music analyst. Provide FACTUAL insights from YouTube titles. Rules: Be precise, research-based, no speculation. Format: Key Analysis, BPM Analysis, Key Changes, BPM Variations, Production Notes, Research Sources.`;\n    }\n    /**\n     * Create optimized user prompt (reduce tokens)\n     */\n    createOptimizedUserPrompt(youtubeTitle, audioAnalysisResult) {\n      let prompt = `Analyze: \"${youtubeTitle}\"`;\n      if (audioAnalysisResult && audioAnalysisResult.finalResult) {\n        const {\n          key,\n          bpm,\n          confidence\n        } = audioAnalysisResult.finalResult;\n        prompt += `\\nAudio: Key ${key}, BPM ${bpm} (${confidence}). Provide additional insights.`;\n      }\n      prompt += `\\nResearch thoroughly, factual only.`;\n      return prompt;\n    }\n    /**\n     * Generate cache key for caching\n     */\n    generateCacheKey(youtubeTitle, audioAnalysisResult) {\n      const audioData = audioAnalysisResult ? JSON.stringify(audioAnalysisResult.finalResult) : '';\n      return `${youtubeTitle}-${audioData}`;\n    }\n    /**\n     * Make request to DeepSeek API with cost control\n     */\n    makeDeepSeekRequest(systemPrompt, userPrompt) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const request = {\n          model: 'deepseek-chat',\n          messages: [{\n            role: 'system',\n            content: systemPrompt\n          }, {\n            role: 'user',\n            content: userPrompt\n          }],\n          temperature: 0.1,\n          max_tokens: _this3.costConfig.maxTokensPerRequest // Reduced token limit\n        };\n        const headers = new HttpHeaders({\n          'Authorization': `Bearer ${_this3.apiKey}`,\n          'Content-Type': 'application/json'\n        });\n        try {\n          const response = yield _this3.http.post(_this3.apiUrl, request, {\n            headers\n          }).toPromise();\n          if (!response || !response.choices || response.choices.length === 0) {\n            throw new Error('Invalid response from DeepSeek API');\n          }\n          return response;\n        } catch (error) {\n          console.error('‚ùå DeepSeek API request failed:', error);\n          throw new Error('Failed to get AI insights');\n        }\n      })();\n    }\n    /**\n     * Parse AI response into structured insights\n     */\n    parseAIResponse(aiResponse, youtubeTitle) {\n      // Extract artist and title from YouTube title\n      const {\n        artist,\n        songTitle\n      } = this.extractArtistAndTitle(youtubeTitle);\n      // Parse the AI response for structured data\n      const insights = this.extractInsightsFromResponse(aiResponse);\n      return {\n        songTitle,\n        artist,\n        keyAnalysis: insights.keyAnalysis || 'Analysis pending',\n        bpmAnalysis: insights.bpmAnalysis || 'Analysis pending',\n        keyChanges: insights.keyChanges || [],\n        bpmVariations: insights.bpmVariations || [],\n        productionNotes: insights.productionNotes || [],\n        researchSources: insights.researchSources || [],\n        confidence: insights.confidence || 'medium',\n        timestamp: new Date()\n      };\n    }\n    /**\n     * Extract artist and title from YouTube title\n     */\n    extractArtistAndTitle(fullTitle) {\n      // Common patterns: \"Artist - Song Title\", \"Artist: Song Title\"\n      const patterns = [/^(.+?)\\s*[-‚Äì‚Äî]\\s*(.+)$/,\n      // \"Artist - Song\"\n      /^(.+?)\\s*:\\s*(.+)$/,\n      // \"Artist: Song\"\n      /^(.+?)\\s+ft\\.?\\s+(.+?)\\s*[-‚Äì‚Äî]\\s*(.+)$/,\n      // \"Artist ft. Other - Song\"\n      /^(.+?)\\s+feat\\.?\\s+(.+?)\\s*[-‚Äì‚Äî]\\s*(.+)$/ // \"Artist feat. Other - Song\"\n      ];\n      for (const pattern of patterns) {\n        const match = fullTitle.match(pattern);\n        if (match) {\n          return {\n            artist: match[1].trim(),\n            songTitle: match[2] ? match[2].trim() : fullTitle.trim()\n          };\n        }\n      }\n      // Fallback: use full title as song title, unknown artist\n      return {\n        artist: 'Unknown Artist',\n        songTitle: fullTitle.trim()\n      };\n    }\n    /**\n     * Extract structured insights from AI response\n     */\n    extractInsightsFromResponse(aiResponse) {\n      const insights = {};\n      // Extract key analysis\n      const keyMatch = aiResponse.match(/Key Analysis:\\s*(.+?)(?=\\n|$)/i);\n      if (keyMatch) insights.keyAnalysis = keyMatch[1].trim();\n      // Extract BPM analysis\n      const bpmMatch = aiResponse.match(/BPM Analysis:\\s*(.+?)(?=\\n|$)/i);\n      if (bpmMatch) insights.bpmAnalysis = bpmMatch[1].trim();\n      // Extract key changes\n      const keyChangesMatch = aiResponse.match(/Key Changes:\\s*(.+?)(?=\\n|$)/i);\n      if (keyChangesMatch) {\n        insights.keyChanges = keyChangesMatch[1].split(',').map(s => s.trim());\n      }\n      // Extract BPM variations\n      const bpmVariationsMatch = aiResponse.match(/BPM Variations:\\s*(.+?)(?=\\n|$)/i);\n      if (bpmVariationsMatch) {\n        insights.bpmVariations = bpmVariationsMatch[1].split(',').map(s => s.trim());\n      }\n      // Extract production notes\n      const productionMatch = aiResponse.match(/Production Notes:\\s*(.+?)(?=\\n|$)/i);\n      if (productionMatch) {\n        insights.productionNotes = productionMatch[1].split(',').map(s => s.trim());\n      }\n      // Extract research sources\n      const sourcesMatch = aiResponse.match(/Research Sources:\\s*(.+?)(?=\\n|$)/i);\n      if (sourcesMatch) {\n        insights.researchSources = sourcesMatch[1].split(',').map(s => s.trim());\n      }\n      return insights;\n    }\n    /**\n     * Update cost control configuration\n     */\n    updateCostConfig(config) {\n      this.costConfig = {\n        ...this.costConfig,\n        ...config\n      };\n      console.log('‚öôÔ∏è Cost control configuration updated:', this.costConfig);\n    }\n    /**\n     * Get current usage statistics\n     */\n    getUsageStats() {\n      return {\n        dailyUsage: this.dailyTokenUsage,\n        dailyLimit: this.costConfig.maxTokensPerDay,\n        userUsage: Object.fromEntries(this.userTokenUsage),\n        userLimit: this.costConfig.maxTokensPerUser,\n        cacheSize: this.requestCache.size,\n        lastReset: this.lastResetDate\n      };\n    }\n    /**\n     * Clear cache to free memory\n     */\n    clearCache() {\n      this.requestCache.clear();\n      console.log('üóëÔ∏è AI insights cache cleared');\n    }\n    /**\n     * Check if API key is configured\n     */\n    isConfigured() {\n      return !!this.apiKey;\n    }\n    /**\n     * Check if service is available (within limits)\n     */\n    isAvailable(userId) {\n      return this.isConfigured() && this.canMakeRequest(userId);\n    }\n    static {\n      this.…µfac = function DeepSeekAIService_Factory(t) {\n        return new (t || DeepSeekAIService)(i0.…µ…µinject(i1.HttpClient), i0.…µ…µinject(i2.WebScrapingService));\n      };\n    }\n    static {\n      this.…µprov = /*@__PURE__*/i0.…µ…µdefineInjectable({\n        token: DeepSeekAIService,\n        factory: DeepSeekAIService.…µfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return DeepSeekAIService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}